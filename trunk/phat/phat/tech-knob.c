/* Generated by GOB (v2.0.12) on Thu Jul 12 18:09:11 2007
   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 12

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "tech-knob.h"

#include "tech-knob-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */
static const GEnumValue _tech_knob_state_values[] = {
	{ TK_STATE_IDLE, (char *)"TK_STATE_IDLE", (char *)"idle" },
	{ TK_STATE_PRESSED, (char *)"TK_STATE_PRESSED", (char *)"pressed" },
	{ TK_STATE_DRAGGING, (char *)"TK_STATE_DRAGGING", (char *)"dragging" },
	{ 0, NULL, NULL }
};

GType
tech_knob_state_get_type (void)
{
	static GType type = 0;
	if ___GOB_UNLIKELY(type == 0)
		type = g_enum_register_static ("TechKnobState", _tech_knob_state_values);
	return type;
}

/* self casting macros */
#define SELF(x) TECH_KNOB(x)
#define SELF_CONST(x) TECH_KNOB_CONST(x)
#define IS_SELF(x) TECH_IS_KNOB(x)
#define TYPE_SELF TECH_TYPE_KNOB
#define SELF_CLASS(x) TECH_KNOB_CLASS(x)

#define SELF_GET_CLASS(x) TECH_KNOB_GET_CLASS(x)

/* self typedefs */
typedef TechKnob Self;
typedef TechKnobClass SelfClass;

/* here are local prototypes */
static void ___object_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);
static void ___object_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);
static void tech_knob_init (TechKnob * o) G_GNUC_UNUSED;
static void tech_knob_class_init (TechKnobClass * class) G_GNUC_UNUSED;
static void tech_knob_unref_anim_list (GList * list) G_GNUC_UNUSED;
static GList * tech_knob_get_anim_list (char * name) G_GNUC_UNUSED;
static void tech_knob_check_curr_anim (TechKnob * self) G_GNUC_UNUSED;
static void ___6_tech_knob_size_request (GtkWidget * widget, GtkRequisition * requisition) G_GNUC_UNUSED;
static gint ___7_tech_knob_expose_event (GtkWidget * widget, GdkEventExpose * event) G_GNUC_UNUSED;
static gint ___8_tech_knob_button_press_event (GtkWidget * widget, GdkEventButton * event) G_GNUC_UNUSED;
static gint ___9_tech_knob_button_release_event (GtkWidget * widget, GdkEventButton * event) G_GNUC_UNUSED;
static gint ___a_tech_knob_motion_notify_event (GtkWidget * widget, GdkEventMotion * event) G_GNUC_UNUSED;
static gint tech_knob_knob_timer (TechKnob * self) G_GNUC_UNUSED;
static void tech_knob_update_mouse_update (TechKnob * self) G_GNUC_UNUSED;
static void tech_knob_update_mouse (TechKnob * self, gint x, gint y) G_GNUC_UNUSED;
static void tech_knob_update_mouse_abs (TechKnob * self, gint x, gint y) G_GNUC_UNUSED;

enum {
	PROP_0,
	PROP_ANIM_NAME
};

/* pointer to the class of our parent */
static GtkRangeClass *parent_class = NULL;

/* Short form macros */
#define self_unref_anim_list tech_knob_unref_anim_list
#define self_new tech_knob_new
#define self_get_anim_list tech_knob_get_anim_list
#define self_check_curr_anim tech_knob_check_curr_anim
#define self_knob_timer tech_knob_knob_timer
#define self_update_mouse_update tech_knob_update_mouse_update
#define self_update_mouse tech_knob_update_mouse
#define self_update_mouse_abs tech_knob_update_mouse_abs
GType
tech_knob_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (TechKnobClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) tech_knob_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (TechKnob),
			0 /* n_preallocs */,
			(GInstanceInitFunc) tech_knob_init,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_RANGE, "TechKnob", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((TechKnob *)g_object_new(tech_knob_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static TechKnob * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static TechKnob *
GET_NEW_VARG (const char *first, ...)
{
	TechKnob *ret;
	va_list ap;
	va_start (ap, first);
	ret = (TechKnob *)g_object_new_valist (tech_knob_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "Tech:Knob::finalize"
	TechKnob *self G_GNUC_UNUSED = TECH_KNOB (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
#line 50 "tech-knob.gob"
	if(self->_priv->anim_name) { g_free ((gpointer) self->_priv->anim_name); self->_priv->anim_name = NULL; }
#line 143 "tech-knob.c"
}
#undef __GOB_FUNCTION__

static void 
tech_knob_init (TechKnob * o G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Tech:Knob::init"
	o->_priv = G_TYPE_INSTANCE_GET_PRIVATE(o,TECH_TYPE_KNOB,TechKnobPrivate);
#line 46 "tech-knob.gob"
	o->_priv->anim_list =  NULL ;
#line 154 "tech-knob.c"
#line 49 "tech-knob.gob"
	o->_priv->anim_name =  NULL ;
#line 157 "tech-knob.c"
}
#undef __GOB_FUNCTION__
#line 32 "tech-knob.gob"
static void 
tech_knob_class_init (TechKnobClass * class G_GNUC_UNUSED)
#line 163 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) class;
	GtkWidgetClass *gtk_widget_class = (GtkWidgetClass *)class;

	g_type_class_add_private(class,sizeof(TechKnobPrivate));

	parent_class = g_type_class_ref (GTK_TYPE_RANGE);

#line 134 "tech-knob.gob"
	gtk_widget_class->size_request = ___6_tech_knob_size_request;
#line 139 "tech-knob.gob"
	gtk_widget_class->expose_event = ___7_tech_knob_expose_event;
#line 176 "tech-knob.gob"
	gtk_widget_class->button_press_event = ___8_tech_knob_button_press_event;
#line 208 "tech-knob.gob"
	gtk_widget_class->button_release_event = ___9_tech_knob_button_release_event;
#line 256 "tech-knob.gob"
	gtk_widget_class->motion_notify_event = ___a_tech_knob_motion_notify_event;
#line 183 "tech-knob.c"
	g_object_class->finalize = ___finalize;
	g_object_class->get_property = ___object_get_property;
	g_object_class->set_property = ___object_set_property;
    {
	GParamSpec   *param_spec;

	param_spec = g_param_spec_string
		("anim_name" /* name */,
		 "anim_name" /* nick */,
		 "Name of the animation to use" /* blurb */,
		 "new-knob02.png" /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (g_object_class,
		PROP_ANIM_NAME,
		param_spec);
    }
 {
#line 32 "tech-knob.gob"

	class->pixbuf_cache = g_hash_table_new( g_str_hash, g_str_equal );
    
#line 205 "tech-knob.c"
 }
}
#undef __GOB_FUNCTION__

static void
___object_set_property (GObject *object,
	guint property_id,
	const GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "Tech:Knob::set_property"
{
	TechKnob *self G_GNUC_UNUSED;

	self = TECH_KNOB (object);

	switch (property_id) {
	case PROP_ANIM_NAME:
		{
#line 123 "tech-knob.gob"

	    self->_priv->anim_name = g_strdup( g_value_get_string(VAL) );
	    self_check_curr_anim( self );
	
#line 229 "tech-knob.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__

static void
___object_get_property (GObject *object,
	guint property_id,
	GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "Tech:Knob::get_property"
{
	TechKnob *self G_GNUC_UNUSED;

	self = TECH_KNOB (object);

	switch (property_id) {
	case PROP_ANIM_NAME:
		{
#line 127 "tech-knob.gob"

	    g_value_set_string(VAL, self->_priv->anim_name );
	
#line 262 "tech-knob.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__



#line 41 "tech-knob.gob"
static void 
tech_knob_unref_anim_list (GList * list)
#line 282 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::unref_anim_list"
#line 41 "tech-knob.gob"
	g_return_if_fail (list != NULL);
#line 287 "tech-knob.c"
{
#line 41 "tech-knob.gob"
	
	g_list_foreach( list, (GFunc) g_object_unref, NULL );
	g_list_free( list );
    }}
#line 294 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 59 "tech-knob.gob"
GtkWidget * 
tech_knob_new (void)
#line 300 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::new"
{
#line 59 "tech-knob.gob"
	
	GtkWidget *ret = (GtkWidget *) GET_NEW;
	return GTK_WIDGET(ret);
    }}
#line 309 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 66 "tech-knob.gob"
static GList * 
tech_knob_get_anim_list (char * name)
#line 315 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::get_anim_list"
{
#line 66 "tech-knob.gob"
	

	GError *err = NULL;
	GdkPixbuf *animation; 
	GList *retval = NULL;
	int x, w;

	
	animation = gdk_pixbuf_new_from_file( name, &err );
	if( animation ) {
	    w = gdk_pixbuf_get_width( animation );

	    for(x=0; x<w; x+=KNOB_SIZE ) {
		GdkPixbuf *pixbuf = gdk_pixbuf_new_subpixbuf( animation, x, 0, KNOB_SIZE, KNOB_SIZE );
		retval = g_list_append( retval, pixbuf );
	    }
	    return retval;
	} else {
	    // Create empty GdkPixBuf...
	    g_warning( "Can not load anim %s", name );
	    return NULL;
	}
    }}
#line 343 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 90 "tech-knob.gob"
static void 
tech_knob_check_curr_anim (TechKnob * self)
#line 349 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::check_curr_anim"
#line 90 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 90 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 356 "tech-knob.c"
{
#line 90 "tech-knob.gob"
	
	//GdkPixbuf *anim = g_hash_table_lookup( SELF_CLASS( G_OBJECT(self)->klass )->pixbuf_cache, self->_priv->anim_name );
	
	GList *anim;

	//printf( "hi... called with%d \n", self->_priv->anim_name );
	if( self->_priv->anim_name )
	    anim = g_hash_table_lookup( SELF_CLASS( G_OBJECT_GET_CLASS(self) )->pixbuf_cache, self->_priv->anim_name );
	else {
	    
	    return;
	}

	if( anim == NULL )
	    //anim = self_load_anim( self );
	    anim = self_get_anim_list( self->_priv->anim_name );

	if( anim != self->_priv->anim_list ) {
	    //g_object_unref( self->_priv->curr_anim );
	    if( self->_priv->anim_list )
		self_unref_anim_list( self->_priv->anim_list );
	    self->_priv->anim_list = anim;
	}

	// TODO: self_expose( self );
    }}
#line 385 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 134 "tech-knob.gob"
static void 
___6_tech_knob_size_request (GtkWidget * widget G_GNUC_UNUSED, GtkRequisition * requisition)
#line 391 "tech-knob.c"
#define PARENT_HANDLER(___widget,___requisition) \
	{ if(GTK_WIDGET_CLASS(parent_class)->size_request) \
		(* GTK_WIDGET_CLASS(parent_class)->size_request)(___widget,___requisition); }
{
#define __GOB_FUNCTION__ "Tech:Knob::size_request"
{
#line 134 "tech-knob.gob"
	
	requisition->width = KNOB_SIZE;
	requisition->height = KNOB_SIZE;
    }}
#line 403 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 139 "tech-knob.gob"
static gint 
___7_tech_knob_expose_event (GtkWidget * widget G_GNUC_UNUSED, GdkEventExpose * event)
#line 410 "tech-knob.c"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->expose_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->expose_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::expose_event"
{
#line 139 "tech-knob.gob"
	

	Self *self = SELF( widget );
	//GtkWidget *widget = GTK_WIDGET( self );
	GtkRange *range = GTK_RANGE( self );
	gfloat dx, dy;

	if (event->count > 0)
	    return FALSE;

	GtkAdjustment *adj = gtk_range_get_adjustment( range );
	//gdk_window_clear_area(widget->window, 0, 0, widget->allocation.width, widget->allocation.height);

	dx = adj->value - adj->lower;
	dy = adj->upper - adj->lower;
	GList *framelist = self->_priv->anim_list;

	if (dy != 0) {
	    GdkPixbuf *pixbuf;

	    dx = MIN(MAX(dx / dy, 0), 1);
	    //dx = (1-dx) * (g_list_length( framelist )-0.5) * 0.75 + 0.125 * g_list_length( framelist );
	    dx = (dx) * (g_list_length( framelist ) - 1 );

	    pixbuf = GDK_PIXBUF( g_list_nth_data( framelist, (int) dx) );

	    gdk_pixbuf_render_to_drawable_alpha( pixbuf, widget->window,
		    0, 0, widget->allocation.x, widget->allocation.y,
		    gdk_pixbuf_get_width( pixbuf ), gdk_pixbuf_get_height( pixbuf ), GDK_PIXBUF_ALPHA_FULL, 0, 0,0,0 );
	}
	else
	    g_warning( "dy=0\n" );

	return FALSE;
    }}
#line 454 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 176 "tech-knob.gob"
static gint 
___8_tech_knob_button_press_event (GtkWidget * widget G_GNUC_UNUSED, GdkEventButton * event)
#line 461 "tech-knob.c"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->button_press_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->button_press_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::button_press_event"
{
#line 176 "tech-knob.gob"
	

	Self *self = SELF( widget );
	//g_return_val_if_fail(widget != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(self), FALSE);
	g_return_val_if_fail(event != NULL, FALSE);


	switch (self->_priv->state) {
	    case TK_STATE_IDLE:
		switch (event->button) {
		    case 1:
		    case 3:
			gtk_grab_add( GTK_WIDGET( self ));
			self->_priv->state = TK_STATE_PRESSED;
			self->_priv->saved_x = event->x + widget->allocation.x;
			self->_priv->saved_y = event->y + widget->allocation.y;
			printf( "saving %f, %f\n", (float) event->x, (float) event->y );
			break;

		    default:
			break;
		}
		break;

	    default:
		break;
	}

	return FALSE;
    }}
#line 501 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 208 "tech-knob.gob"
static gint 
___9_tech_knob_button_release_event (GtkWidget * widget G_GNUC_UNUSED, GdkEventButton * event)
#line 508 "tech-knob.c"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->button_release_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->button_release_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::button_release_event"
{
#line 208 "tech-knob.gob"
	

	g_return_val_if_fail(widget != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(widget), FALSE);
	g_return_val_if_fail(event != NULL, FALSE);
	Self *self = SELF( widget );

	

	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );

	switch (self->_priv->state) {
	    case TK_STATE_PRESSED:
		gtk_grab_remove( GTK_WIDGET( self ) );
		self->_priv->state = TK_STATE_IDLE;

		switch (event->button) {
		    case 1:
			adj->value -= adj->page_increment;
			gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
			break;

		    case 3:
			adj->value += adj->page_increment;
			gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
			break;

		    default:
			break;
		}
		break;

	    case TK_STATE_DRAGGING:
		gtk_grab_remove(GTK_WIDGET( self ));
		self->_priv->state = TK_STATE_IDLE;

		if (gtk_range_get_update_policy( GTK_RANGE( self ) ) != GTK_UPDATE_CONTINUOUS && self->_priv->old_value != adj->value)
		    gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");

		break;

	    default:
		break;
	}

	return FALSE;
    }}
#line 564 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 256 "tech-knob.gob"
static gint 
___a_tech_knob_motion_notify_event (GtkWidget * widget G_GNUC_UNUSED, GdkEventMotion * event)
#line 571 "tech-knob.c"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->motion_notify_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->motion_notify_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::motion_notify_event"
{
#line 256 "tech-knob.gob"
	
	GdkModifierType mods;
	gint x, y;
	Self *self = SELF( widget );
	GtkWidget *widget = GTK_WIDGET(self);

	g_return_val_if_fail(widget != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(widget), FALSE);
	g_return_val_if_fail(event != NULL, FALSE);

	//knob = GTK_KNOB(widget);

	x = event->x;
	y = event->y;

	if (event->is_hint || (event->window != widget->window))
	    gdk_window_get_pointer(widget->window, &x, &y, &mods);

	switch (self->_priv->state) {
	    case TK_STATE_PRESSED:
		self->_priv->state = TK_STATE_DRAGGING;
		/* fall through */

	    case TK_STATE_DRAGGING:
		if (mods & GDK_BUTTON1_MASK) {
		    self_update_mouse(self, x, y);
		    return TRUE;
		} else if (mods & GDK_BUTTON3_MASK) {
		    self_update_mouse_abs(self, x, y);
		    return TRUE;
		}
		break;

	    default:
		break;
	}

	return FALSE;
    }}
#line 619 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 296 "tech-knob.gob"
static gint 
tech_knob_knob_timer (TechKnob * self)
#line 626 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::knob_timer"
#line 296 "tech-knob.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 296 "tech-knob.gob"
	g_return_val_if_fail (TECH_IS_KNOB (self), (gint )0);
#line 633 "tech-knob.c"
{
#line 296 "tech-knob.gob"
	
	//g_return_val_if_fail(knob != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(knob), FALSE);

	GtkUpdateType policy = gtk_range_get_update_policy( GTK_RANGE( self ) );
	if (policy == GTK_UPDATE_DELAYED) {
	    GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );
	    gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
	}

	return FALSE;	/* don't keep running this timer */
    }}
#line 648 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 309 "tech-knob.gob"
static void 
tech_knob_update_mouse_update (TechKnob * self)
#line 654 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::update_mouse_update"
#line 309 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 309 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 661 "tech-knob.c"
{
#line 309 "tech-knob.gob"
	
	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );
	if (gtk_range_get_update_policy( GTK_RANGE( self )) == GTK_UPDATE_CONTINUOUS)
	    gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
	else {
	    gtk_widget_draw(GTK_WIDGET(self), NULL);

	    if (gtk_range_get_update_policy( GTK_RANGE( self )) == GTK_UPDATE_DELAYED) {
		if (self->_priv->timer)
		    gtk_timeout_remove(self->_priv->timer);

		self->_priv->timer = gtk_timeout_add (SCROLL_DELAY_LENGTH, (GtkFunction) self_knob_timer,
			(gpointer) self);
	    }
	}
    }}
#line 680 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 326 "tech-knob.gob"
static void 
tech_knob_update_mouse (TechKnob * self, gint x, gint y)
#line 686 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::update_mouse"
#line 326 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 326 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 693 "tech-knob.c"
{
#line 326 "tech-knob.gob"
	
	gfloat old_value;
	gfloat dv;

	//g_return_if_fail(knob != NULL);
	//g_return_if_fail(GTK_IS_KNOB(knob));
	
	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );

	old_value = adj->value;

	dv = (self->_priv->saved_y - y) * adj->step_increment;
	printf( "wattn : old= %f, dv=%f, y = %d\n", old_value, dv, y );
	self->_priv->saved_x = x;
	self->_priv->saved_y = y;

	adj->value += dv;

	if (adj->value != old_value)
	    self_update_mouse_update(self);
    }}
#line 717 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 348 "tech-knob.gob"
static void 
tech_knob_update_mouse_abs (TechKnob * self, gint x, gint y)
#line 723 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::update_mouse_abs"
#line 348 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 348 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 730 "tech-knob.c"
{
#line 348 "tech-knob.gob"
	
	gfloat old_value;
	gdouble angle;

	//g_return_if_fail(knob != NULL);
	//g_return_if_fail(GTK_IS_KNOB(knob));

	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );

	old_value = adj->value;

	x -= GTK_WIDGET(self)->allocation.x;
	x -= KNOB_SIZE>>1;
	y -= GTK_WIDGET(self)->allocation.y;
	y -= KNOB_SIZE>>1;
	y = -y;	/* inverted cartesian graphics coordinate system */

	angle = atan2(y, x) / MY_PI;
	if (angle < -0.5)
	    angle += 2;

	angle = -(2.0/3.0) * (angle - 1.25);	/* map [1.25pi, -0.25pi] onto [0, 1] */
	angle *= adj->upper - adj->lower;
	angle += adj->lower;

	adj->value = angle;

	if (adj->value != old_value)
	    self_update_mouse_update(self);
    }}
#line 763 "tech-knob.c"
#undef __GOB_FUNCTION__
